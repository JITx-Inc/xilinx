defpackage xilinx/platforms/series-7/generator :
  import core
  import collections
  import maybe-utils

  import xilinx/pinouts
  import xilinx/pin-ir
  import xilinx/platforms/series-7/types
  import xilinx/platforms/series-7/parser

;============================================================
;========================= Structs ==========================
;============================================================

deftype XilinxPin
defstruct DedicatedXilinxPin <: XilinxPin :
  pin-ref:String
  name:String
  bank:Maybe<Int>
  funcs:Tuple<SpecialFunction>
defstruct IOXilinxPin <: XilinxPin :
  pin-ref:String
  name:String
  bank:Int
  channel:Int
  funcs:Tuple<SpecialFunction>

defn XilinxPin (pd:PinDescriptor) -> XilinxPin :
  match(parse(pd)) :
    (pt:DedicatedPinType) :
      DedicatedXilinxPin(pin-ref(pd), name(pd), bank(pd), func(pt))
    (pt:IOPinType) :
      IOXilinxPin(pin-ref(pd), name(pd), bank(pt), channel(pt), funcs(pt))

;============================================================
;======================== Generator =========================
;============================================================

val SIMPLE-TMPLT = \<s>
pcb-bundle virtex-7-io-bank :
  port S : pin[[0 25]]
  port D : diff-pair[[1 through 24]]

pcb-component %_ :
  port IO: virtex-7-io-bank[[ %_ ]]
  pin-properties :
    [pin:Ref | pads:Ref ... | bank:Int ]
%_
%_
<s>

defn simple-component (name:String, pinout:XilinxPinout) -> String :
  val dedicated-pins = Vector<DedicatedXilinxPin>()
  val io-pins = Vector<IOXilinxPin>()
  for pd in pins(pinout) do :
    match(XilinxPin(pd)) :
      (p:IOXilinxPin) : add(io-pins, p)
      (p:DedicatedXilinxPin) : add(dedicated-pins, p)

  val dedicated-props = make-dedicated-pin-properties(dedicated-pins)

  val [io-bank-ids-str, io-props] = make-io-pin-properties(io-pins)

  to-string $ SIMPLE-TMPLT % [name, io-bank-ids-str, dedicated-props, io-props]

;============================================================
;========================= Helpers ==========================
;============================================================

;Converts dedicated pins into rows for the pin properties table
defn make-dedicated-pin-properties (pins:Vector<DedicatedXilinxPin>) -> String :
  ;Groups of dedicated pins by pin name
  ;Use a vector to preserve input order
  val groups = Vector<Vector<DedicatedXilinxPin>>()
  ;Index into the groups vector by pin name
  val group-index-by-name = HashTable<String,Int>()

  ;Fill groups
  for p in pins do :
    match(get?(group-index-by-name, name(p))) :
      (i:Int) :
        add(groups[i], p)
      (_) :
        val group = Vector<DedicatedXilinxPin>()
        add(group, p)
        group-index-by-name[name(p)] = length(groups)
        add(groups, group)

  ;Build properties for each row
  val rows = for g in groups seq :
    val name = /name(g[0])
    val bank = with-default(/bank(g[0]), 0)
    val pins = qsort $ seq(pin-ref, g)
    to-string $ "    [%_ | %_ | %_]" % [name, string-join(pins, " "), bank]
  string-join(rows, "\n")

defn make-io-pin-properties (pins:Vector<IOXilinxPin>) -> [String,String] :
  val banks = IntTable<Vector<IOXilinxPin>>()
  for p in pins do :
    val bank-vec = set?(banks, bank(p), {Vector<IOXilinxPin>()})
    add(bank-vec, p)
  val rows = for kv in banks seq-cat :
    val bid = key(kv)
    val bank = value(kv)
    if length(bank) != 50 :
      throw(Exception("Bank %_ does not have 50 pins: %_" % [bid, length(bank)]))

    val pins-in-order = Array<IOXilinxPin>(50)
    for p in bank do :
      if channel(p) == 0 :
        pins-in-order[0] = p
      else if channel(p) == 25 :
        pins-in-order[49] = p
      else :
        val cid = channel(p)
        val diff-pol = match(find({_ is DifferentialIOType}, funcs(p))) :
          (dt:DifferentialIOType) : polarity(dt)
          (_) : throw(Exception("Channel %_ of bank %_ is not a differential pair" % [channel(p), bid]))
        val i = (2 * cid - 1) when diff-pol is Diff-P else (2 * cid)
        pins-in-order[i] = p

    val row-0 = to-string $ "    [ IO[%_].S[0] | %_ | %_ ]" % [bid, pin-ref(pins-in-order[0]), bid]
    val row-25 = to-string $ "    [ IO[%_].S[25] | %_ | %_ ]" % [bid, pin-ref(pins-in-order[49]), bid]
    val diff-pair-rows = for cid in 1 through 24 seq-cat :
      val pin-P = pins-in-order[2 * cid - 1]
      val pin-N = pins-in-order[2 * cid]
      [
      to-string $ "    [ IO[%_].D[%_].P | %_ | %_ ]" % [bid, cid, pin-ref(pin-P), bid]
      to-string $ "    [ IO[%_].D[%_].N | %_ | %_ ]" % [bid, cid, pin-ref(pin-N), bid]
      ]
    cat-all([[row-0], diff-pair-rows, [row-25]])
  val pin-prop-str = string-join(rows, "\n")
  val bank-ids = qsort $ to-tuple $ keys(banks)
  val bank-ids-str = string-join(bank-ids, " ")
  [bank-ids-str, pin-prop-str]

;============================================================
;======================== Utilities =========================
;============================================================

defn strip-bank (name:String) -> String :
  name[0 to last-index-of-char(name, '_')]

defmulti with-default<?T> (x:?T|False, default:?T) -> T
defmethod with-default<?T> (x:False, default:?T) -> T : default
defmethod with-default<?T> (x:Maybe<?T>, default:?T) -> T :
  match(x) :
    (x:One<T>) : value(x)
    (_) : default
defmethod with-default<?T> (x:?T, default:?T) -> T : x

;============================================================

;Deprecated
val EXCLUDED-ROW-CHARS = ['I', 'O', 'Q', 'S', 'X', 'Z']
defn row-name-to-index (row-name:String) -> Int :
  defn row-char-to-index (c:Char) -> Int :
    if c < 'A' or c > 'Z' :
      throw(Exception("Invalid character in row index: %_" % [c]))
    val offset = with-default{_, 6} $ for e in EXCLUDED-ROW-CHARS index-when :
      if c == e :
        throw(Exception("Invalid character in row index: %_" % [c]))
      c < e
    to-int(c) - to-int('A') - offset + 1
  val base = 26 - length(EXCLUDED-ROW-CHARS)
  reduce({base * _0 + _1}, 0, seq(row-char-to-index, row-name))
