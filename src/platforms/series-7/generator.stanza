defpackage xilinx/platforms/series-7/generator :
  import core
  import collections
  import maybe-utils

  import xilinx/pinouts
  import xilinx/pin-ir
  import xilinx/platforms/series-7/types
  import xilinx/platforms/series-7/parser

;============================================================
;========================= Structs ==========================
;============================================================

deftype XilinxPin
defstruct DedicatedXilinxPin <: XilinxPin :
  pin-refs:Tuple<PadRef> with:
    updater => sub-pin-refs
  name:String
  bank:Maybe<Int>
  funcs:Tuple<SpecialFunction>
defstruct IOXilinxPin <: XilinxPin :
  pin-ref:PadRef
  name:String
  bank:Int
  channel:Int
  funcs:Tuple<SpecialFunction>
  final-ref:String|False with:
    init => false
    setter => set-final-ref

defn XilinxPin (pd:PinDescriptor) -> XilinxPin :
  match(parse(pd)) :
    (pt:DedicatedPinType) :
      DedicatedXilinxPin([PadRef(pin-ref(pd))], name(pd), bank(pd), func(pt))
    (pt:IOPinType) :
      IOXilinxPin(PadRef(pin-ref(pd)), name(pd), bank(pt), channel(pt), funcs(pt))

defn final-ref! (p:IOXilinxPin) -> String :
  match(final-ref(p)) :
    (s:String) : s
    (_) : throw(Exception("Final reference name for pin %_ has not been set yet"
      % [name(p)]))

defstruct PadRef <: Equalable&Comparable<PadRef>&Hashable :
  row:String
  col:Int
with:
  equalable => true
  hashable => true
defmethod compare (a:PadRef, b:PadRef) -> Int :
  compare([length(row(a)), row(a), col(a)], [length(row(b)), row(b), col(b)])
defmethod print (o:OutputStream, p:PadRef) -> False :
  print(o, "%_[%_]" % [row(p), col(p)])
defn PadRef (ref-str:String) -> PadRef :
  defn throw-invalid () -> Void :
    throw(Exception("Invalid pad reference %_" % [ref-str]))
  val split = match(index-when(digit?, ref-str)) :
    (i:Int) : throw-invalid() when i < 1 else i
    (_) : throw-invalid()
  val row = ref-str[0 to split]
  val col = match(to-int(ref-str[split to false])) :
    (i:Int) : i
    (_) : throw-invalid()
  PadRef(row, col)

defstruct PinProperties :
  name:String
  pads:Tuple<PadRef>
  bank:Int
defmethod print (o:OutputStream, p:PinProperties) -> False :
  print(o, "[ %_ | %* | %_ ]" % [name(p), join(pads(p), " "), bank(p)])

defstruct PortDeclaration :
  name:String
  type:String
  indices:Tuple<Int|Range>
defmethod print (o:OutputStream, p:PortDeclaration) -> False :
  val index-arr-str = ("[[ %* ]]" % [join(indices(p), " ")]) when (length(indices(p)) > 0) else ""
  print(o, "port %_: %_%_" % [name(p), type(p), index-arr-str])

defstruct SupportStmt :
  name:String
  support-pairs:Tuple<KeyValue<String,String>>
defmethod print (o:OutputStream, x:SupportStmt) -> False :
  if length(support-pairs) <= 0 :
    println(o, "  supports %_" % [name(x)])
  else :
    println(o, "  supports %_ :" % [name(x)])
    do({println(o, "    %_" % [_])}, support-pairs)

;============================================================
;======================== Generator =========================
;============================================================

val SIMPLE-TMPLT =
\<s>#use-added-syntax(jitx)
defpackage components/%_ :
  import core
  import collections
  import jitx
  import jitx/commands
  import jsl/bundles
  import jsl/bundles/debug
  import ocdb/utils/box-symbol

pcb-bundle virtex-7-gt-clock :
  port I : diff-pair[[0 to 2]]

pcb-bundle virtex-7-gt-quad :
  port C : lane-pair[[0 to 4]]

pcb-bundle virtex-7-io-bank :
  port S: pin[[0 25]]
  port D: diff-pair[[1 through 24]]

pcb-component %_ :
  %*
  pin-properties :
    [ pin:Ref | pads:Ref ... | bank:Int ]
    %*
  make-box-symbol()
  assign-landpattern(%_)
<s>

defn simple-component (name:String, landpattern-name:String, pinout:XilinxPinout) -> String :
  val ungrouped-dedicated-pins = Vector<DedicatedXilinxPin>()
  val io-pins = Vector<IOXilinxPin>()
  for pd in pins(pinout) do :
    match(XilinxPin(pd)) :
      (p:IOXilinxPin) : add(io-pins, p)
      (p:DedicatedXilinxPin) : add(ungrouped-dedicated-pins, p)

  val dedicated-pins = group-by-name(ungrouped-dedicated-pins)

  val [dd-ports, dd-props] = make-dedicated-pin-properties(dedicated-pins)

  val [io-ports, io-props] = make-io-pin-properties(io-pins)

  to-string $ SIMPLE-TMPLT % [name, name, join(cat(dd-ports, io-ports), "\n  "),
    join(cat(dd-props, io-props), "\n    "), landpattern-name]

;============================================================
;========================= Helpers ==========================
;============================================================

;Groups pins with the same name into one pin
defn group-by-name (pins:Seqable<DedicatedXilinxPin>) -> Vector<DedicatedXilinxPin> :
  val result = Vector<DedicatedXilinxPin>()
  ;Index of pin group by pin name
  val group-index-by-name = HashTable<String,Int>()

  ;Perform grouping
  for p in pins do :
    match(get?(group-index-by-name, name(p))) :
      (i:Int) :
        val old-pin = result[i]
        if bank(old-pin) != bank(p) :
          throw(Exception("Pin %_ has bank %_ for pads %_ but bank %_ for pads %_" % [name(p), bank(p), pin-refs(p),
            bank(old-pin), pin-refs(old-pin)]))
        val new-pin-refs = qsort(cat(pin-refs(old-pin), pin-refs(p)))
        result[i] = sub-pin-refs(old-pin, new-pin-refs)
      (_) :
        group-index-by-name[name(p)] = length(result)
        add(result, p)
  result

;Converts dedicated pins into rows for the pin properties table
defn make-dedicated-pin-properties (pins:Vector<DedicatedXilinxPin>) -> [Tuple<PortDeclaration>,Tuple<PinProperties>] :
  ;TODO: create a generalized framework for building and declaring bundles
  val port-decls = Vector<PortDeclaration>()
  ;Config mode pins
  add(port-decls, PortDeclaration("M", "pin", [0 to 3]))
  ;JTAG
  add(port-decls, PortDeclaration("JTAG", "jtag", []))
  ;Multi-bank ports
  val vcco-banks = IntSet()
  val gtclock-banks = IntSet()
  val gtp-banks = IntSet()
  val gtx-banks = IntSet()
  val gth-banks = IntSet()
  val gtavttrcal-banks = IntSet()
  val gtrref-banks = IntSet()

  defn default-pin-properties (p:DedicatedXilinxPin) -> PinProperties :
    val bank = maybe-default(/bank(p), 0)
    val name = if bank == 0 and suffix?(name(p), "_0") :
      name(p)[0 to (length(name(p)) - 2)]
    else : name(p)
    PinProperties(name, pin-refs(p), bank)

  ;Build properties for each pin
  val props = to-tuple $ for p in pins seq : match(funcs(p)[0]) :
    (type:ConfigModeType) :
      PinProperties(to-string("M[%_]" % [index(type)]), pin-refs(p), 0)

    (type:JTAGType) :
      switch(signal(type)) :
        TCK : PinProperties("JTAG.tck", pin-refs(p), 0)
        TMS : PinProperties("JTAG.tms", pin-refs(p), 0)
        TDI : PinProperties("JTAG.tdi", pin-refs(p), 0)
        TDO : PinProperties("JTAG.tdo", pin-refs(p), 0)

    (type:TransceiverClockType) :
      val bank = match(bank(p)) :
        (b:One<Int>) : value(b)
        (_) : throw(Exception("Transceiver clock pin %_ has no bank" % [name(p)]))
      add(gtclock-banks, bank)
      val pol-str = "P" when polarity(type) is Diff-P else "N"
      val pin-name = to-string $ "MGTREFCLK[%_].I[%_].%_" % [bank, index(type), pol-str]
      PinProperties(pin-name, pin-refs(p), bank)

    (type:TransceiverQuadType) :
      val bank = match(bank(p)) :
        (b:One<Int>) : value(b)
        (_) : throw(Exception("Transceiver pin %_ has no bank" % [name(p)]))
      val dir-str = "TX" when direction(type) is GTTX else "RX"
      val pol-str = "P" when polarity(type) is Diff-P else "N"
      val class-str = switch(class(type)) :
        GTP :
          add(gtp-banks, bank)
          "MGTP"
        GTX :
          add(gtx-banks, bank)
          "MGTX"
        GTH :
          add(gth-banks, bank)
          "MGTH"
      val pin-name = to-string $ "%_[%_].C[%_].%_.%_" % [class-str, bank, index(type), dir-str, pol-str]
      PinProperties(pin-name, pin-refs(p), bank)

    (type:TransceiverRefType) :
      if prefix?(name(p), "MGTAVTTRCAL") :
        val bank = match(bank(p)) :
          (b:One<Int>) : value(b)
          (_) : throw(Exception("Calibration resistor pin %_ has no bank" % [name(p)]))
        add(gtavttrcal-banks, bank)
        val name = to-string $ "MGTAVTTRCAL[%_]" % [bank]
        PinProperties(name, pin-refs(p), bank)
      else if prefix?(name(p), "MGTRREF") :
        val bank = match(bank(p)) :
          (b:One<Int>) : value(b)
          (_) : throw(Exception("Calibration resistor pin %_ has no bank" % [name(p)]))
        add(gtavttrcal-banks, bank)
        val name = to-string $ "MGTRREF[%_]" % [bank]
        PinProperties(name, pin-refs(p), bank)
      else :
        throw(Exception("Unknown transceiver pin type %_" % [name(p)]))

    (type:PowerRailType) :
      if prefix?(name(p), "VCCO") :
        val bank = match(bank(p)) :
          (b:One<Int>) : value(b)
          (_) : throw(Exception("Power supply pin %_ has no bank" % [name(p)]))
        add(vcco-banks, bank)
        val name = to-string $ "VCCO[%_]" % [bank]
        PinProperties(name, pin-refs(p), bank)
      else :
        default-pin-properties(p)

    (_) :
      default-pin-properties(p)

  add(port-decls, PortDeclaration("VCCO", "pin", qsort(vcco-banks)))
  if length(gtclock-banks) > 0 :
    add(port-decls, PortDeclaration("MGTREFCLK", "virtex-7-gt-clock", qsort(gtclock-banks)))
  if length(gtrref-banks) > 0 :
    add(port-decls, PortDeclaration("MGTRREF", "pin", qsort(gtrref-banks)))
  if length(gtavttrcal-banks) > 0 :
    add(port-decls, PortDeclaration("MGTAVTTRCAL", "pin", qsort(gtavttrcal-banks)))
  for (name in ["MGTP", "MGTX", "MGTH"], banks in [gtp-banks, gtx-banks, gth-banks]) do :
    if length(banks) > 0 :
      add(port-decls, PortDeclaration(name, "virtex-7-gt-quad", qsort(banks)))
  [to-tuple(port-decls), props]

;Converts IO pins into rows for the pin properties table
;Also generates the final reference names for each pin
defn make-io-pin-properties (pins:Vector<IOXilinxPin>) -> [Tuple<PortDeclaration>,Tuple<PinProperties>] :
  val banks = IntTable<Vector<IOXilinxPin>>()
  for p in pins do :
    val bank-vec = set?(banks, bank(p), {Vector<IOXilinxPin>()})
    add(bank-vec, p)

  val props = to-tuple $ for kv in banks seq-cat :
    val bid = key(kv)
    val bank = value(kv)
    if length(bank) != 50 :
      throw(Exception("Bank %_ does not have 50 pins: %_" % [bid, length(bank)]))
    for p in bank seq :
      if channel(p) == 0 :
        set-final-ref(p, to-string("IO[%_].S[0]" % [bid]))
        PinProperties(final-ref!(p), [pin-ref(p)], bid)
      else if channel(p) == 25 :
        set-final-ref(p, to-string("IO[%_].S[25]" % [bid]))
        PinProperties(final-ref!(p), [pin-ref(p)], bid)
      else :
        val cid = channel(p)
        val diff-pol = match(find({_ is DifferentialIOType}, funcs(p))) :
          (dt:DifferentialIOType) : polarity(dt)
          (_) : throw(Exception("Channel %_ of bank %_ is not a differential pair" % [cid, bid]))
        if diff-pol is Diff-P :
          set-final-ref(p, to-string("IO[%_].D[%_].P" % [bid, cid]))
          PinProperties(final-ref!(p), [pin-ref(p)], bid)
        else :
          set-final-ref(p, to-string("IO[%_].D[%_].N" % [bid, cid]))
          PinProperties(final-ref!(p), [pin-ref(p)], bid)

  val bank-ids = qsort $ to-tuple $ keys(banks)
  val bank-decl = PortDeclaration("IO", "virtex-7-io-bank", bank-ids)
  [[bank-decl], to-tuple(props)]

;Generate the support statements for the IO pins
;Must be called after final pin references are set (by make-io-pin-properties)
defn make-io-supports (pins:Vector<IOXilinxPin>) -> Tuple<SupportStmt> :
  val adc-positives = Vector<IOXilinxPin|False>()
  val adc-negatives = Vector<IOXilinxPin|False>()

  for p in pins do :
    for func in funcs(p) do :
      match(func) :
        (func:AnalogInputType) :
          val adc-vec = adc-positives when polarity(func) is Diff-P else adc-negatives
          lengthen(adc-vec, (index(func) + 1), false)
          adc-vec[index(func)] = p
        (func:SingleRegionClockType) :
        (func:MemoryGroupType|MemoryStrobeType) :
          ;TODO: memory byte group
          false
        (func) :
          throw(Exception("Unexpected IO special function type %_" % [func]))


  val result = Vector<SupportStmt>()

  ;Analog digital converter supports
  val len-adc-p = length(adc-positives)
  val len-adc-n = length(adc-negatives)
  if len-adc-p > len-adc-n :
    throw(Exception("Analog differential positive input %_ has no match" % [adc-positives[len-adc-p - 1]]))
  if len-adc-n < len-adc-p :
    throw(Exception("Analog differential negative input %_ has no match" % [adc-negatives[len-adc-n - 1]]))
  for i in 0 to len-adc-p do :
    val [adc-p, adc-n] = match(adc-positives[i], adc-negatives[i]) :
      (adc-p:IOXilinxPin, adc-n:IOXilinxPin) : [adc-p, adc-n]
      (adc-p:IOXilinxPin, _) :
        throw(Exception("Analog differential positive input %_ has no match" % [adc-p]))
      (_, adc-n:IOXilinxPin) :
        throw(Exception("Analog differential negative input %_ has no match" % [adc-n]))
      (_, _) :
        throw(Exception("Analog differential pair %_ is missing" % [i]))
    add(result, SupportStmt("virtex-7-analog-gpio", [
      "virtex-7-adc.ADC.P" => final-ref(adc-p),
      "virtex-7-adc.ADC.N" => final-ref(adc-n)]))


;============================================================
;======================== Utilities =========================
;============================================================

defn strip-bank (name:String) -> String :
  name[0 to last-index-of-char(name, '_')]

defn with-default<?T> (x:?T|False, default:?T) -> T :
  match(x) :
    (x:T) : x
    (_) : default

defn maybe-default<?T> (x:Maybe<?T>, default:?T) -> T :
  match(x) :
    (x:One<T>) : value(x)
    (_) : default

;============================================================

;Deprecated
val EXCLUDED-ROW-CHARS = ['I', 'O', 'Q', 'S', 'X', 'Z']
defn row-name-to-index (row-name:String) -> Int :
  defn row-char-to-index (c:Char) -> Int :
    if c < 'A' or c > 'Z' :
      throw(Exception("Invalid character in row index: %_" % [c]))
    val offset = with-default{_, 6} $ for e in EXCLUDED-ROW-CHARS index-when :
      if c == e :
        throw(Exception("Invalid character in row index: %_" % [c]))
      c < e
    to-int(c) - to-int('A') - offset + 1
  val base = 26 - length(EXCLUDED-ROW-CHARS)
  reduce({base * _0 + _1}, 0, seq(row-char-to-index, row-name))
