defpackage xilinx/platforms/series-7/generator :
  import core
  import collections
  import maybe-utils

  import xilinx/pinouts
  import xilinx/pin-ir
  import xilinx/platforms/series-7/types
  import xilinx/platforms/series-7/parser

;============================================================
;========================= Structs ==========================
;============================================================

deftype XilinxPin
defstruct DedicatedXilinxPin <: XilinxPin :
  pin-ref:String
  name:String
  bank:Maybe<Int>
  funcs:Tuple<SpecialFunction>
defstruct IOXilinxPin <: XilinxPin :
  pin-ref:String
  name:String
  bank:Int
  channel:Int
  funcs:Tuple<SpecialFunction>

defn XilinxPin (pd:PinDescriptor) -> XilinxPin :
  match(parse(pd)) :
    (pt:DedicatedPinType) :
      DedicatedXilinxPin(pin-ref(pd), name(pd), bank(pd), func(pt))
    (pt:IOPinType) :
      IOXilinxPin(pin-ref(pd), name(pd), bank(pt), channel(pt), funcs(pt))

;============================================================
;======================== Generator =========================
;============================================================

val SIMPLE-TMPLT = \<s>
pcb-component %_ :
  port io: virtex-7-io-bank[[ %_ ]]
  pin-properties :
    [pin:Ref | pads:Ref ... | bank:Int ]
%_
<s>

defn simple-component (name:String, pinout:XilinxPinout) -> String :
  val dedicated-pins = Vector<DedicatedXilinxPin>()
  val io-pins = Vector<IOXilinxPin>()
  for pd in pins(pinout) do :
    match(XilinxPin(pd)) :
      (p:IOXilinxPin) : add(io-pins, p)
      (p:DedicatedXilinxPin) : add(dedicated-pins, p)

  ;TODO: dedicated pin parsing

  val [io-bank-ids-str, io-props] = make-io-pin-properties(io-pins)

  to-string $ SIMPLE-TMPLT % [name, io-bank-ids-str, io-props]

;============================================================
;========================= Helpers ==========================
;============================================================

;Converts dedicated pins into rows for the pin properties table
defn make-dedicated-pin-properties (pins:Vector<DedicatedXilinxPin>) -> String :
  ;TODO: dedicated pin parsing
  ""

defn make-io-pin-properties (pins:Vector<IOXilinxPin>) -> [String,String] :
  val banks = IntTable<Vector<IOXilinxPin>>()
  for p in pins do :
    val bank-vec = set?(banks, bank(p), {Vector<IOXilinxPin>()})
    add(bank-vec, p)
  val rows = for kv in banks seq-cat :
    val bid = key(kv)
    val bank = value(kv)
    if length(bank) != 50 :
      throw(Exception("Bank %_ does not have 50 pins: %_" % [bid, length(bank)]))

    val pins-in-order = Array<IOXilinxPin>(50)
    for p in bank do :
      if channel(p) == 0 :
        pins-in-order[0] = p
      else if channel(p) == 25 :
        pins-in-order[49] = p
      else :
        val cid = channel(p)
        val diff-pol = match(find({_ is DifferentialIOType}, funcs(p))) :
          (dt:DifferentialIOType) : polarity(dt)
          (_) : throw(Exception("Channel %_ of bank %_ is not a differential pair" % [channel(p), bid]))
        val i = (2 * cid - 1) when diff-pol is Diff-P else (2 * cid)
        pins-in-order[i] = p

    val row-0 = to-string $ "    [ io[%_].s[0] | %_ | %_ ]" % [bid, pin-ref(pins-in-order[0]), bid]
    val row-25 = to-string $ "    [ io[%_].s[25] | %_ | %_ ]" % [bid, pin-ref(pins-in-order[49]), bid]
    val diff-pair-rows = for cid in 1 through 24 seq-cat :
      val pin-P = pins-in-order[2 * cid - 1]
      val pin-N = pins-in-order[2 * cid]
      [
      to-string $ "    [ io[%_].d[%_].P | %_ | %_ ]" % [bid, cid, pin-ref(pin-P), bid]
      to-string $ "    [ io[%_].d[%_].N | %_ | %_ ]" % [bid, cid, pin-ref(pin-N), bid]
      ]
    cat-all([[row-0], diff-pair-rows, [row-25]])
  val pin-prop-str = string-join(rows, "\n")
  val bank-ids = qsort $ to-tuple $ keys(banks)
  val bank-ids-str = string-join(bank-ids, " ")
  [bank-ids-str, pin-prop-str]

;============================================================
;======================== Utilities =========================
;============================================================

defn with-default<?T> (x:?T|False, default:?T) -> T :
  match(x) :
    (x:T) : x
    (_) : default

defn with-default<?T> (x:Maybe<?T>, default:?T) -> T :
  match(x) :
    (x:One<T>) : value(x)
    (_) : default

;============================================================

;Deprecated
val EXCLUDED-ROW-CHARS = ['I', 'O', 'Q', 'S', 'X', 'Z']
defn row-name-to-index (row-name:String) -> Int :
  defn row-char-to-index (c:Char) -> Int :
    if c < 'A' or c > 'Z' :
      throw(Exception("Invalid character in row index: %_" % [c]))
    val offset = with-default{_, 6} $ for e in EXCLUDED-ROW-CHARS index-when :
      if c == e :
        throw(Exception("Invalid character in row index: %_" % [c]))
      c < e
    to-int(c) - to-int('A') - offset + 1
  val base = 26 - length(EXCLUDED-ROW-CHARS)
  reduce({base * _0 + _1}, 0, seq(row-char-to-index, row-name))
