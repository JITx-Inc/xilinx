defpackage xilinx/platforms/series-7/generator :
  import core
  import collections
  import maybe-utils

  import xilinx/bundler
  import xilinx/pinouts
  import xilinx/pin-ir
  import xilinx/platforms/series-7/types
  import xilinx/platforms/series-7/parser

;============================================================
;========================= Structs ==========================
;============================================================

deftype XilinxPin
defstruct DedicatedXilinxPin <: XilinxPin :
  pin-refs:Tuple<PadRef> with:
    updater => sub-pin-refs
  name:String
  bank:Maybe<Int>
  funcs:Tuple<SpecialFunction>
defstruct IOXilinxPin <: XilinxPin :
  pin-ref:PadRef
  name:String
  bank:Int
  channel:Int
  mem-byte-grp:Maybe<Int>
  funcs:Tuple<SpecialFunction>
  final-ref:String|False with:
    init => false
    setter => set-final-ref

defn XilinxPin (pd:PinDescriptor) -> XilinxPin :
  match(parse(pd)) :
    (pt:DedicatedPinType) :
      DedicatedXilinxPin([PadRef(pin-ref(pd))], name(pd), bank(pd), func(pt))
    (pt:IOPinType) :
      IOXilinxPin(PadRef(pin-ref(pd)), name(pd), bank(pt), channel(pt), mem-byte-grp(pd), funcs(pt))

defn final-ref! (p:IOXilinxPin) -> String :
  match(final-ref(p)) :
    (s:String) : s
    (_) : throw(Exception("Final reference name for pin %_ has not been set yet"
      % [name(p)]))

defstruct PadRef <: Equalable&Comparable<PadRef>&Hashable :
  row:String
  col:Int
with:
  equalable => true
  hashable => true
defmethod compare (a:PadRef, b:PadRef) -> Int :
  compare([length(row(a)), row(a), col(a)], [length(row(b)), row(b), col(b)])
defmethod print (o:OutputStream, p:PadRef) -> False :
  print(o, "%_[%_]" % [row(p), col(p)])
defn PadRef (ref-str:String) -> PadRef :
  defn throw-invalid () -> Void :
    throw(Exception("Invalid pad reference %_" % [ref-str]))
  val split = match(index-when(digit?, ref-str)) :
    (i:Int) : throw-invalid() when i < 1 else i
    (_) : throw-invalid()
  val row = ref-str[0 to split]
  val col = match(to-int(ref-str[split to false])) :
    (i:Int) : i
    (_) : throw-invalid()
  PadRef(row, col)

defstruct PinProperties :
  name:String
  pads:Tuple<PadRef>
  bank:Int
  mem-byte-grp:Maybe<Int> with:
    default => None()
defmethod print (o:OutputStream, p:PinProperties) -> False :
  print(o, "[ %_ | %* | %_ | %_ ]" % [name(p), join(pads(p), " "), bank(p), maybe-default(mem-byte-grp(p), "-")])

defstruct PortDeclaration :
  name:String
  type:String
  indices:Tuple<Int>
defmethod print (o:OutputStream, p:PortDeclaration) -> False :
  val index-arr-str = ("[%_]" % [pretty-indices-str(indices(p))]) when (length(indices(p)) > 0) else ""
  print(o, "port %_: %_%_" % [name(p), type(p), index-arr-str])

;Generated code statement or group of statements
deftype Expr :
  String <: Expr
  Printable <: Expr

;Generated statement with a nested body
defstruct BodyExpr <: Expr :
  head:Expr
  body:Tuple<Expr>
defmethod print (o:OutputStream, x:BodyExpr) -> False :
  val o2 = IndentedStream(o, 2)
  print(o, head(x))
  do(lnprint{o2, _}, body(x))

;Convenience function for generating a for loop statement
defn for-stmt (for-var:Expr, for-list:Expr, body:Tuple<Expr>) -> Expr :
  BodyExpr(to-string("for %_ in %_ do :" % [for-var, for-list]), body)

;Convenience function for generating a for loop statement with multiple iterators
defn for-stmt (for-vars:Seqable<Expr>, for-lists:Seqable<Expr>, body:Tuple<Expr>) -> Expr :
  val var-strs = seq({"%_ in %_" % [_, _]}, for-vars, for-lists)
  BodyExpr(to-string("for (%,) do :" % [var-strs]), body)

;Convenience function for generating a supports statement
;The body of the supports will contain "name.key(pair) => value(pair)" for each pair in 'support-pairs'
;Do not include the bundle name in the key
defn support-stmt (name:Expr, support-pairs:Tuple<KeyValue<Expr,Expr>>) -> Expr :
  val body = to-tuple $ for pair in support-pairs seq :
    to-string("%_.%_ => %_" % [name, key(pair), value(pair)])
  BodyExpr(to-string("supports %_ :" % [name]), body)

;============================================================
;======================== Generator =========================
;============================================================

val SIMPLE-TMPLT =
\<s>#use-added-syntax(jitx)
defpackage components/%_ :
  import core
  import collections
  import jitx
  import jitx/commands
  import jsl/bundles
  import jsl/bundles/debug
  import ocdb/utils/box-symbol

pcb-bundle virtex-7-io-bank :
  port S : pin[[0 25]]
  port D : diff-pair[[1 through 24]]

pcb-bundle virtex-7-gt-quad :
  port C : lane-pair[4]

pcb-bundle virtex-7-gt-clock :
  port I : diff-pair[2]

pcb-bundle virtex-7-diff-gpio :
  port D : diff-pair

pcb-bundle virtex-7-adc :
  port ADC : diff-pair

pcb-bundle virtex-7-config-data :
  port D : pin[32]

pcb-bundle virtex-7-revision-select :
  port RS : pin[2]

pcb-bundle virtex-7-vref :
  pin VREF

pcb-bundle virtex-7-memory-strobe :
  port DQS : diff-pair

pcb-bundle virtex-7-memory-byte-pin :
  pin MBP

pcb-bundle virtex-7-memory-byte-group :
  port DQS : diff-pair
  port P : pin[8]

pcb-bundle virtex-7-memory-byte-group-with-vref :
  port DQS : diff-pair
  port P : pin[8]
  pin VREF

pcb-bundle virtex-7-bpi-control :
  pin ADV ; address output valid
  pin FCS ; chip select
  pin FOE ; output enable
  pin FWE ; write enable

pcb-bundle virtex-7-bpi-address :
  port ADDR : pin[[0 to 29]]

pcb-bundle virtex-7-single-region-clock :
  port SRCC : diff-pair

pcb-bundle virtex-7-multi-region-clock :
  port MRCC : diff-pair

pcb-bundle virtex-7-dci-vref-n :
  pin VRN

pcb-bundle virtex-7-dci-vref-p :
  pin VRP

%_
<s>

defn simple-component (name:String, landpattern-name:String, pinout:XilinxPinout) -> String :
  val ungrouped-dedicated-pins = Vector<DedicatedXilinxPin>()
  val io-pins = Vector<IOXilinxPin>()
  for pd in pins(pinout) do :
    match(XilinxPin(pd)) :
      (p:IOXilinxPin) : add(io-pins, p)
      (p:DedicatedXilinxPin) : add(ungrouped-dedicated-pins, p)

  val [dedicated-pins, gnd-pins] = group-by-name(ungrouped-dedicated-pins)

  val [dd-ports, dd-props] = make-dedicated-pin-properties(dedicated-pins, gnd-pins)

  val [io-bank-ids, io-ports, io-props] = make-io-pin-properties(io-pins)

  val supp-stmts = make-io-supports(io-pins, io-bank-ids)

  val props-stmt = BodyExpr("pin-properties :", to-tuple(
    cat(["[ pin:Ref | pads:Ref ... | bank:Int | memory-byte-group:Int ]"],
    seq(to-string, cat(dd-props, io-props)))))
  val comp-stmt = BodyExpr("pcb-component %_ :" % [name], to-tuple $ cat-all $ [
    seq(to-string, cat(dd-ports, io-ports)),
    [props-stmt],
    supp-stmts,
    ["make-box-symbol()",
    "assign-landpattern(%_)" % [landpattern-name]]
    ])

  to-string $ SIMPLE-TMPLT % [name, comp-stmt]

;============================================================
;========================= Helpers ==========================
;============================================================

;Groups pins with the same name into one pin
;Returns the GND pins separately
defn group-by-name (pins:Seqable<DedicatedXilinxPin>) -> [Vector<DedicatedXilinxPin>,Vector<DedicatedXilinxPin>] :
  val result = Vector<DedicatedXilinxPin>()
  val gnd-pins = Vector<DedicatedXilinxPin>()
  ;Index of pin group by pin name
  val group-index-by-name = HashTable<String,Int>()

  ;Perform grouping
  for p in pins do :
    if name(p) == "GND" :
      add(gnd-pins, p)
    else :
      match(get?(group-index-by-name, name(p))) :
        (i:Int) :
          val old-pin = result[i]
          if bank(old-pin) != bank(p) :
            throw(Exception("Pin %_ has bank %_ for pads %_ but bank %_ for pads %_" % [name(p), bank(p), pin-refs(p),
              bank(old-pin), pin-refs(old-pin)]))
          val new-pin-refs = qsort(cat(pin-refs(old-pin), pin-refs(p)))
          result[i] = sub-pin-refs(old-pin, new-pin-refs)
        (_) :
          group-index-by-name[name(p)] = length(result)
          add(result, p)
  [result, gnd-pins]

;Converts dedicated pins into rows for the pin properties table
;Also returns port declarations and net statements
defn make-dedicated-pin-properties (pins:Vector<DedicatedXilinxPin>, gnd-pins:Vector<DedicatedXilinxPin>) -> [Tuple<PortDeclaration>,Tuple<PinProperties>] :
  val port-decls = Vector<PortDeclaration>()

  ;Static port declarations
  ;GND pins
  add(port-decls, PortDeclaration("GND", "pin", to-tuple(0 to length(gnd-pins))))
  ;Config mode pins
  add(port-decls, PortDeclaration("M", "pin", [0 1 2]))
  ;JTAG
  add(port-decls, PortDeclaration("JTAG", "jtag", []))

  ;Dynamic port declaration bank sets
  val vcco-banks = IntSet()
  val gtclock-banks = IntSet()
  val gtp-banks = IntSet()
  val gtx-banks = IntSet()
  val gth-banks = IntSet()
  val gtavttrcal-banks = IntSet()
  val gtrref-banks = IntSet()

  ;Default pin property row for non-specially-handled dedicated pins
  defn default-pin-properties (p:DedicatedXilinxPin) -> PinProperties :
    val bank = maybe-default(/bank(p), 0)
    val name = if bank == 0 and suffix?(name(p), "_0") :
      name(p)[0 to (length(name(p)) - 2)]
    else : name(p)
    PinProperties(name, pin-refs(p), bank)

  ;Build properties for each pin
  val non-gnd-props = for p in pins seq : match(funcs(p)[0]) :
    (type:ConfigModeType) :
      PinProperties(to-string("M[%_]" % [index(type)]), pin-refs(p), 0)

    (type:JTAGType) :
      switch(signal(type)) :
        TCK : PinProperties("JTAG.tck", pin-refs(p), 0)
        TMS : PinProperties("JTAG.tms", pin-refs(p), 0)
        TDI : PinProperties("JTAG.tdi", pin-refs(p), 0)
        TDO : PinProperties("JTAG.tdo", pin-refs(p), 0)

    (type:TransceiverClockType) :
      val bank = match(bank(p)) :
        (b:One<Int>) : value(b)
        (_) : throw(Exception("Transceiver clock pin %_ has no bank" % [name(p)]))
      add(gtclock-banks, bank)
      val pol-str = "P" when polarity(type) is Diff-P else "N"
      val pin-name = to-string $ "MGTREFCLK[%_].I[%_].%_" % [bank, index(type), pol-str]
      PinProperties(pin-name, pin-refs(p), bank)

    (type:TransceiverQuadType) :
      val bank = match(bank(p)) :
        (b:One<Int>) : value(b)
        (_) : throw(Exception("Transceiver pin %_ has no bank" % [name(p)]))
      val dir-str = "TX" when direction(type) is GTTX else "RX"
      val pol-str = "P" when polarity(type) is Diff-P else "N"
      val class-str = switch(class(type)) :
        GTP :
          add(gtp-banks, bank)
          "MGTP"
        GTX :
          add(gtx-banks, bank)
          "MGTX"
        GTH :
          add(gth-banks, bank)
          "MGTH"
      val pin-name = to-string $ "%_[%_].C[%_].%_.%_" % [class-str, bank, index(type), dir-str, pol-str]
      PinProperties(pin-name, pin-refs(p), bank)

    (type:TransceiverRefType) :
      if prefix?(name(p), "MGTAVTTRCAL") :
        val bank = match(bank(p)) :
          (b:One<Int>) : value(b)
          (_) : throw(Exception("Calibration resistor pin %_ has no bank" % [name(p)]))
        add(gtavttrcal-banks, bank)
        val name = to-string $ "MGTAVTTRCAL[%_]" % [bank]
        PinProperties(name, pin-refs(p), bank)
      else if prefix?(name(p), "MGTRREF") :
        val bank = match(bank(p)) :
          (b:One<Int>) : value(b)
          (_) : throw(Exception("Calibration resistor pin %_ has no bank" % [name(p)]))
        add(gtavttrcal-banks, bank)
        val name = to-string $ "MGTRREF[%_]" % [bank]
        PinProperties(name, pin-refs(p), bank)
      else :
        throw(Exception("Unknown transceiver pin type %_" % [name(p)]))

    (type:PowerRailType) :
      if prefix?(name(p), "VCCO") :
        val bank = match(bank(p)) :
          (b:One<Int>) : value(b)
          (_) : throw(Exception("Power supply pin %_ has no bank" % [name(p)]))
        add(vcco-banks, bank)
        val name = to-string $ "VCCO[%_]" % [bank]
        PinProperties(name, pin-refs(p), bank)
      else :
        default-pin-properties(p)

    (_) :
      default-pin-properties(p)

  ;GND pin properties
  qsort!({pin-refs(_)[0]}, gnd-pins)
  val gnd-props = for (i in 0 to false, p in gnd-pins) seq :
    PinProperties(to-string("GND[%_]" % [i]), pin-refs(p), 0)
  val props = to-tuple(cat(gnd-props, non-gnd-props))

  ;Dynamic multi-bank port declarations
  add(port-decls, PortDeclaration("VCCO", "pin", to-tuple(vcco-banks)))
  if length(gtclock-banks) > 0 :
    add(port-decls, PortDeclaration("MGTREFCLK", "virtex-7-gt-clock", to-tuple(gtclock-banks)))
  if length(gtrref-banks) > 0 :
    add(port-decls, PortDeclaration("MGTRREF", "pin", to-tuple(gtrref-banks)))
  if length(gtavttrcal-banks) > 0 :
    add(port-decls, PortDeclaration("MGTAVTTRCAL", "pin", to-tuple(gtavttrcal-banks)))
  for (name in ["MGTP", "MGTX", "MGTH"], banks in [gtp-banks, gtx-banks, gth-banks]) do :
    if length(banks) > 0 :
      add(port-decls, PortDeclaration(name, "virtex-7-gt-quad", to-tuple(banks)))

  [to-tuple(port-decls), props]

;Converts IO pins into rows for the pin properties table
;Also generates the final reference names for each pin
defn make-io-pin-properties (pins:Vector<IOXilinxPin>) -> [Tuple<Int>,Tuple<PortDeclaration>,Tuple<PinProperties>] :
  val banks = IntTable<Vector<IOXilinxPin>>()
  for p in pins do :
    val bank-vec = set?(banks, bank(p), {Vector<IOXilinxPin>()})
    add(bank-vec, p)

  val props = to-tuple $ for kv in banks seq-cat :
    val bid = key(kv)
    val bank = value(kv)
    if length(bank) != 50 :
      throw(Exception("Bank %_ does not have 50 pins: %_" % [bid, length(bank)]))
    for p in bank seq :
      if channel(p) == 0 :
        set-final-ref(p, to-string("IO[%_].S[0]" % [bid]))
        PinProperties(final-ref!(p), [pin-ref(p)], bid, mem-byte-grp(p))
      else if channel(p) == 25 :
        set-final-ref(p, to-string("IO[%_].S[25]" % [bid]))
        PinProperties(final-ref!(p), [pin-ref(p)], bid, mem-byte-grp(p))
      else :
        val cid = channel(p)
        val diff-pol = match(find({_ is DifferentialIOType}, funcs(p))) :
          (dt:DifferentialIOType) : polarity(dt)
          (_) : throw(Exception("Channel %_ of bank %_ is not a differential pair" % [cid, bid]))
        if diff-pol is Diff-P :
          set-final-ref(p, to-string("IO[%_].D[%_].P" % [bid, cid]))
          PinProperties(final-ref!(p), [pin-ref(p)], bid, mem-byte-grp(p))
        else :
          set-final-ref(p, to-string("IO[%_].D[%_].N" % [bid, cid]))
          PinProperties(final-ref!(p), [pin-ref(p)], bid, mem-byte-grp(p))

  val bank-ids = qsort $ to-tuple $ keys(banks)
  val bank-decl = PortDeclaration("IO", "virtex-7-io-bank", bank-ids)
  [bank-ids, [bank-decl], to-tuple(props)]

;Generate the support statements for the IO pins
;Must be called after final pin references are set (by make-io-pin-properties)
defn make-io-supports (pins:Vector<IOXilinxPin>, bank-ids:Tuple<Int>) -> Vector<Expr> :
  val bank-ids-str = pretty-indices-str(bank-ids)
  val bank-ids-for-loop-str = compactify-for-loop-indices(bank-ids)

  ;Configuration mode pins
  val config-pins = Array<IOXilinxPin>(32)

  ;Revision select
  val rev-sel = Array<IOXilinxPin>(2)

  val bpi-addr = Array<IOXilinxPin>(30)
  ;[Address valid, chip select, output enable, write enable]
  val bpi-extras = Array<IOXilinxPin>(4)

  ;Clocks
  val srcc-pins = HashSet<[Int,Int]>()
  val mrcc-pins = HashSet<[Int,Int]>()

  ;VREF
  val vref-pins = Vector<IOXilinxPin>()

  for p in pins do :
    for func in funcs(p) do :
      match(func) :
        (func:AnalogInputType) :
          ;Handled separately
          false
        (func:ConfigDataType) :
          config-pins[index(func)] = p
        (func:RevisionType) :
          rev-sel[index(func)] = p
        (func:BPIAddressType) :
          bpi-addr[index(func)] = p
        (func:BPIAddressValidType) :
          bpi-extras[0] = p
        (func:BPIChipSelectType) :
          bpi-extras[1] = p
        (func:BPIOutputEnableType) :
          bpi-extras[2] = p
        (func:BPIWriteEnableType) :
          bpi-extras[3] = p
        (func:SingleRegionClockType) :
          add(srcc-pins, [bank(p), channel(p)])
        (func:MultiRegionClockType) :
          add(mrcc-pins, [bank(p), channel(p)])
        (func:MemoryGroupType|MemoryStrobeType) :
          ;Handled separately
          false
        (func:DifferentialIOType) :
          ;Ignore diff polarity marking
          false
        (func:VREFType) :
          add(vref-pins, p)
        (func:DCIRefType) :
          ;Handled separately
          false
        (func) :
          throw(Exception("Unexpected IO special function type %_" % [func]))

  val result = Vector<Expr>()

  ;GPIO support
  add(result, for-stmt("bank", bank-ids-for-loop-str, [
    support-stmt("gpio", ["p" => "IO[bank].S[0]"])
    for-stmt("channel", "1 through 24", [
      support-stmt("virtex-7-diff-gpio", [
        "D.P" => "IO[bank].D[channel].P"
        "D.N" => "IO[bank].D[channel].N"
        ])
      ])
    support-stmt("gpio", ["p" => "IO[bank].S[25]"])
    ]))

  ;Configuration data support
  add(result, support-stmt("virtex-7-config-data",
    to-tuple $ for i in 0 to 32 seq :
      ("D[%_]" % [i]) => final-ref!(config-pins[i])
    ))

  ;Revision select
  add(result, support-stmt("virtex-7-revision-select", [
    "RS[0]" => final-ref!(rev-sel[0]),
    "RS[1]" => final-ref!(rev-sel[1]),
    ]))

  ;Byte peripheral interface supports
  add(result, support-stmt("virtex-7-bpi-control", [
    "ADV" => final-ref!(bpi-extras[0]),
    "FCS" => final-ref!(bpi-extras[1]),
    "FOE" => final-ref!(bpi-extras[2]),
    "FWE" => final-ref!(bpi-extras[3])
    ]))
  add(result, support-stmt("virtex-7-bpi-address",
    to-tuple $ for i in 0 to 29 seq :
      ("ADDR[%_]" % [i]) => final-ref!(bpi-addr[i])
    ))

  ;VREF supports
  add(result, for-stmt("p", to-string("[%,]" % [seq(final-ref!, vref-pins)]), [
    support-stmt("virtex-7-vref", [
      "VREF" => "p"
    ])]))

  ;Clock supports
  add(result, for-stmt("bank-and-channel", to-string(qsort(srcc-pins, compare)), [
    "val [bank, channel] = bank-and-channel",
    support-stmt("virtex-7-single-region-clock", [
      "SRCC.P" => "IO[bank].D[channel].P",
      "SRCC.N" => "IO[bank].D[channel].N"])
    ]))
  add(result, for-stmt("bank-and-channel", to-string(qsort(mrcc-pins, compare)), [
    "val [bank, channel] = bank-and-channel",
    support-stmt("virtex-7-multi-region-clock", [
      "MRCC.P" => "IO[bank].D[channel].P",
      "MRCC.N" => "IO[bank].D[channel].N"])
    ]))

  add-all(result, make-adc-supports(pins))
  add-all(result, make-dci-supports(pins))
  add-all(result, make-memory-strobe-supports(pins))
  add-all(result, make-memory-byte-group-supports(pins, bank-ids))

  result

defn make-adc-supports (pins:Vector<IOXilinxPin>) -> Tuple<Expr> :
  val AnalogBundleType = new BundleType<Int,IOXilinxPin> :
    defmethod print (o:OutputStream, this) : print(o, "analog bundle type")
    defmethod width (this) : 2
    defmethod in-bundle? (this, p:IOXilinxPin) -> KeyValue<Int,Int>|False :
      match(find({_ is AnalogInputType}, funcs(p))) :
        (func:AnalogInputType) :
          switch(polarity(func)) :
            Diff-P :
              index(func) => 0
            Diff-N :
              index(func) => 1
        (_) : false
  val bundles = collect-bundles(AnalogBundleType, pins)
  val bundles* = qsort(key, bundles)
  val bank+channels = to-string $ to-tuple $ for b in bundles* seq :
    val [dp, dn] = value(b) as [IOXilinxPin,IOXilinxPin]
    if bank(dp) != bank(dn) :
      throw(Exception("Analog input pair pins are not the same bank: %_ %_" % [dp, dn]))
    if channel(dp) != channel(dn) :
      throw(Exception("Analog input pair pins are not the same channel: %_ %_" % [dp, dn]))
    [bank(dp), channel(dp)]

  [for-stmt("bank-and-channel", bank+channels, [
    "val [bank, channel] = bank-and-channel",
    support-stmt("virtex-7-adc", [
      "ADC.P" => "IO[bank].D[channel].P",
      "ADC.N" => "IO[bank].D[channel].N"])
    ])]

;Currently assumes the VRN pin is always channel 0 and the VRP pin is always 25
defn make-dci-supports (pins:Vector<IOXilinxPin>) -> Tuple<Expr> :
  val bank-id-set-n = IntSet()
  val bank-id-set-p = IntSet()
  for p in pins do :
    match(find({_ is DCIRefType}, funcs(p))) :
      (func:DCIRefType) :
        switch(transistor-type(func)) :
          DCI-N :
            if channel(p) != 0 :
              throw(Exception("DCI VRN pin is not on channel 0: %_" % [p]))
            if diff-polarity(p) is-not False :
              throw(Exception("DCI VRN pin is differential: %_" % [p]))
            if not add(bank-id-set-n, bank(p)) :
              throw(Exception("Bank %_ has multiple VRN pins" % [bank(p)]))
          DCI-P :
            if channel(p) != 25 :
              throw(Exception("DCI VRP pin is not on channel 25: %_" % [p]))
            if diff-polarity(p) is-not False :
              throw(Exception("DCI VRP pin is differential: %_" % [p]))
            if not add(bank-id-set-p, bank(p)) :
              throw(Exception("Bank %_ has multiple VRP pins" % [bank(p)]))
      (_) : false

  val banks = qsort(bank-id-set-n)
  val banks-p = qsort(bank-id-set-p)
  if banks != banks-p :
    throw(Exception("VRN banks and VRP banks do not match: %_ vs %_" % [banks, banks-p]))

  val banks-str = compactify-for-loop-indices(banks)
  [for-stmt("bank", banks-str, [
    support-stmt("virtex-7-dci-vref-n", [
      "VRN" => "IO[bank].S[0]"]),
    support-stmt("virtex-7-dci-vref-p", [
      "VRP" => "IO[bank].S[25]"])
    ])]

defn make-memory-strobe-supports (pins:Vector<IOXilinxPin>) -> Tuple<Expr> :
  val DQSBundleType = new BundleType<[Int,Int],IOXilinxPin> :
    defmethod print (o:OutputStream, this) : print(o, "memory strobe bundle type")
    defmethod width (this) : 2
    defmethod in-bundle? (this, p:IOXilinxPin) -> KeyValue<[Int,Int],Int>|False :
      match(find({_ is MemoryStrobeType}, funcs(p))) :
        (func:MemoryStrobeType) :
          val grp = match(mem-byte-grp(p)) :
            (i:One<Int>) : value(i)
            (_) : throw(Exception("Memory strobe pin has no memory byte group: %_" % [p]))
          val index = match(diff-polarity(p)) :
            (_:Diff-P) : 0
            (_:Diff-N) : 1
            (_) : throw(Exception("Memory strobe pin is not differential: %_" % [p]))
          [bank(p), grp] => index
        (_) : false
  val strobe-pairs = collect-bundles(DQSBundleType, pins)
  val bank+channels = to-tuple $ for pair in qsort(strobe-pairs, {compare(key(_0), key(_1))}) seq :
    val [dp, dn] = value(pair) as [IOXilinxPin,IOXilinxPin]
    if bank(dp) != bank(dn) :
      throw(Exception("Strobe pair pins are not the same bank: %_ %_" % [dp, dn]))
    if channel(dp) != channel(dn) :
      throw(Exception("Strobe pair pins are not the same channel: %_ %_" % [dp, dn]))
    [bank(dp), channel(dp)]
  [for-stmt("bank-and-channel", to-string(bank+channels), [
    "val [bank, channel] = bank-and-channel",
    support-stmt("virtex-7-memory-strobe", [
      "DQS.P" => "IO[bank].D[channel].P",
      "DQS.N" => "IO[bank].D[channel].N"])
    ])]

defn make-memory-byte-group-supports (pins:Vector<IOXilinxPin>, bank-ids:Tuple<Int>) -> Tuple<Expr> :
  val bank-ids-for-loop-str = compactify-for-loop-indices(bank-ids)
  [
  for-stmt("bank", bank-ids-for-loop-str, [
    for-stmt("channel", "1 through 24", [
      support-stmt("virtex-7-memory-byte-pin", [
        "MBP" => "IO[bank].D[channel].P"]),
      support-stmt("virtex-7-memory-byte-pin", [
        "MBP" => "IO[bank].D[channel].N"])
      ])
    ])
  for-stmt("bank", bank-ids-for-loop-str, [
    for-stmt("group", "0 to 4", [
      BodyExpr("defn match-bank-group (p) :", ["(property?(p.bank) == One(bank)) and",
        "  (property?(p.memory-byte-group) == One(group))"
        ]),
      BodyExpr("supports virtex-7-memory-byte-group :", [
        "require clk:virtex-7-memory-strobe from self",
        "restrict(clk.DQS.P, match-bank-group)",
        "virtex-7-memory-byte-group.DQS.P => clk.DQS.P",
        "virtex-7-memory-byte-group.DQS.N => clk.DQS.N",
        for-stmt("i", "0 to 8", [
          "require p:virtex-7-memory-byte-pin from self",
          "restrict(p.MBP, match-bank-group)"
          "virtex-7-memory-byte-group.P[i] => p.MBP"
          ])
        ])
      ])
    ])
  for-stmt("bank", bank-ids-for-loop-str, [
    for-stmt("group", "0 to 4", [
      BodyExpr("defn match-bank-group (p) :", ["(property?(p.bank) == One(bank)) and (property?(p.memory-byte-group) == One(group))"]),
      BodyExpr("supports virtex-7-memory-byte-group-with-vref :", [
        "require clk:virtex-7-memory-strobe from self",
        "restrict(clk.DQS.P, match-bank-group)",
        "virtex-7-memory-byte-group-with-vref.DQS.P => clk.DQS.P",
        "virtex-7-memory-byte-group-with-vref.DQS.N => clk.DQS.N",
        for-stmt("i", "0 to 8", [
          "require p:virtex-7-memory-byte-pin from self",
          "restrict(p.MBP, match-bank-group)"
          "virtex-7-memory-byte-group-with-vref.P[i] => p.MBP"
          ])
        "require v:virtex-7-vref from self",
        "restrict(v.VREF, fn (p) : property?(p.bank) == One(bank))",
        "virtex-7-memory-byte-group-with-vref.VREF => v.VREF"
        ])
      ])
    ])
  ]

;============================================================
;======================== Utilities =========================
;============================================================

;Groups items into bundles based on a bundle key function
defn group-by-bundle<?K,?V> (key-fn:(V -> ?K|False), xs:Seqable<?V>) -> HashTable<K,Vector<V>> :
  val result = HashTable<K,Vector<V>>()
  for x in xs do :
    match(key-fn(x)) :
      (k:K) :
        val bundle = set?(result, k, {Vector<V>()})
        add(bundle, x)
      (_) :
        false
  result

defn diff-polarity (p:IOXilinxPin) -> Diff-Polarity|False :
  match(find({_ is DifferentialIOType}, funcs(p))) :
    (func:DifferentialIOType) :
      polarity(func)
    (_) : false

defn strip-bank (name:String) -> String :
  name[0 to last-index-of-char(name, '_')]

;Group a set of indices into consecutive ranges where possible
;Sorts the input before compacting
defn compactify (indices:Seqable<Int>) -> Tuple<Int|Range> :
  val result = Vector<Int|Range>()
  var start:Int|False = false
  var end:Int|False = false
  defn finish-current-range () :
    match(start:Int, end:Int) :
      if end > (start + 1) :
        add(result, Range(start, end))
      else :
        add(result, start)
  for i in qsort(indices) do :
    if i == end :
      end = i + 1
    else :
      finish-current-range()
      start = i
      end = i + 1
  finish-current-range()
  to-tuple(result)

defn pretty-indices-str (indices:Seqable<Int>) -> String :
  to-string("[%,]" % [compactify(indices)])

defn compactify-for-loop-indices (indices:Seqable<Int>) -> String :
  defn make-seqable (x:Int|Range) :
    match(x) :
      (x:Int) : [x]
      (x:Range) : x
  val indices* = compactify(indices)
  if length(indices*) == 1 :
    match(indices*[0]) :
      (i:Int) : to-string([i])
      (r:Range) : to-string(r)
  else :
    if any?({_ is Range}, indices*) :
      to-string $ "cat-all([%,])" % [seq(make-seqable, indices*)]
    else :
      to-string(indices*)

defn with-default<?T> (x:?T|False, default:?T) -> T :
  match(x) :
    (x:T) : x
    (_) : default

defn maybe-default<?T> (x:Maybe<?T>, default:?T) -> T :
  match(x) :
    (x:One<T>) : value(x)
    (_) : default

;============================================================

;Deprecated
val EXCLUDED-ROW-CHARS = ['I', 'O', 'Q', 'S', 'X', 'Z']
defn row-name-to-index (row-name:String) -> Int :
  defn row-char-to-index (c:Char) -> Int :
    if c < 'A' or c > 'Z' :
      throw(Exception("Invalid character in row index: %_" % [c]))
    val offset = with-default{_, 6} $ for e in EXCLUDED-ROW-CHARS index-when :
      if c == e :
        throw(Exception("Invalid character in row index: %_" % [c]))
      c < e
    to-int(c) - to-int('A') - offset + 1
  val base = 26 - length(EXCLUDED-ROW-CHARS)
  reduce({base * _0 + _1}, 0, seq(row-char-to-index, row-name))
