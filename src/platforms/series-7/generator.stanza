defpackage xilinx/platforms/series-7/generator :
  import core
  import collections
  import maybe-utils

  import xilinx/pinouts
  import xilinx/pin-ir
  import xilinx/platforms/series-7/types
  import xilinx/platforms/series-7/parser

;============================================================
;========================= Structs ==========================
;============================================================

deftype XilinxPin
defstruct DedicatedXilinxPin <: XilinxPin :
  pin-refs:Tuple<String> with:
    updater => sub-pin-refs
  name:String
  bank:Maybe<Int>
  funcs:Tuple<SpecialFunction>
defstruct IOXilinxPin <: XilinxPin :
  pin-ref:String
  name:String
  bank:Int
  channel:Int
  funcs:Tuple<SpecialFunction>

defn XilinxPin (pd:PinDescriptor) -> XilinxPin :
  match(parse(pd)) :
    (pt:DedicatedPinType) :
      DedicatedXilinxPin([pin-ref(pd)], name(pd), bank(pd), func(pt))
    (pt:IOPinType) :
      IOXilinxPin(pin-ref(pd), name(pd), bank(pt), channel(pt), funcs(pt))

defstruct PinProperties :
  name:String
  pads:Tuple<String>
  bank:Int
defmethod print (o:OutputStream, p:PinProperties) -> False :
  print(o, "[%_ | %* | %_]" % [name(p), join(pads(p), " "), bank(p)])

defstruct PortDeclaration :
  name:String
  type:String
  indices:Tuple<Int>
defmethod print (o:OutputStream, p:PortDeclaration) -> False :
  print(o, "port %_: %_[[ %* ]]" % [name(p), type(p), join(indices(p), " ")])

;============================================================
;======================== Generator =========================
;============================================================

val SIMPLE-TMPLT = \<s>
pcb-bundle virtex-7-gt-quad :
  port C : virtex-7-gt-channel[[0 to 4]]

pcb-bundle virtex-7-gt-channel :
  port TX : diff-pair
  port RX : diff-pair

pcb-bundle virtex-7-io-bank :
  port S: pin[[0 25]]
  port D: diff-pair[[1 through 24]]

pcb-component %_ :
  %*
  pin-properties :
    [ pin:Ref | pads:Ref ... | bank:Int ]
    %*
  make-box-symbol()
  assign-landpattern(%_)
<s>

defn simple-component (name:String, landpattern-name:String, pinout:XilinxPinout) -> String :
  val ungrouped-dedicated-pins = Vector<DedicatedXilinxPin>()
  val io-pins = Vector<IOXilinxPin>()
  for pd in pins(pinout) do :
    match(XilinxPin(pd)) :
      (p:IOXilinxPin) : add(io-pins, p)
      (p:DedicatedXilinxPin) : add(ungrouped-dedicated-pins, p)

  val dedicated-pins = group-by-name(ungrouped-dedicated-pins)

  val [dd-ports, dd-props] = make-dedicated-pin-properties(dedicated-pins)

  val [io-ports, io-props] = make-io-pin-properties(io-pins)

  to-string $ SIMPLE-TMPLT % [name, join(cat(dd-ports, io-ports), "\n  "),
    join(cat(dd-props, io-props), "\n    "), landpattern-name]

;============================================================
;========================= Helpers ==========================
;============================================================

;Groups pins with the same name into one pin
defn group-by-name (pins:Seqable<DedicatedXilinxPin>) -> Vector<DedicatedXilinxPin> :
  val result = Vector<DedicatedXilinxPin>()
  ;Index of pin group by pin name
  val group-index-by-name = HashTable<String,Int>()

  ;Perform grouping
  for p in pins do :
    match(get?(group-index-by-name, name(p))) :
      (i:Int) :
        val old-pin = result[i]
        if bank(old-pin) != bank(p) :
          throw(Exception("Pin %_ has bank %_ for pads %_ but bank %_ for pads %_" % [name(p), bank(p), pin-refs(p),
            bank(old-pin), pin-refs(old-pin)]))
        val new-pin-refs = qsort(cat(pin-refs(old-pin), pin-refs(p)))
        result[i] = sub-pin-refs(old-pin, new-pin-refs)
      (_) :
        group-index-by-name[name(p)] = length(result)
        add(result, p)
  result

;Converts dedicated pins into rows for the pin properties table
defn make-dedicated-pin-properties (pins:Vector<DedicatedXilinxPin>) -> [Tuple<PortDeclaration>,Tuple<PinProperties>] :
  val gtp-banks = IntSet()
  val gtx-banks = IntSet()
  val gth-banks = IntSet()

  ;Build properties for each pin
  val props = to-tuple $ for p in pins seq :
    if any?({prefix?(name(p), _)}, ["MGTP", "MGTX", "MGTH"]) :
      val tqt = match(find({_ is TransceiverQuadType}, funcs(p))) :
        (tqt:TransceiverQuadType) : tqt
        (_) : throw(Exception("No transceiver quad type function found for pin %_" % [name(p)]))
      val bank = match(bank(p)) :
        (b:One<Int>) : value(b)
        (_) : throw(Exception("Transceiver pin %_ has no bank" % [name(p)]))
      val dir-str = "TX" when direction(tqt) is GTTX else "RX"
      val pol-str = "P" when polarity(tqt) is Diff-P else "N"
      val class-str = switch(class(tqt)) :
        GTP :
          add(gtp-banks, bank)
          "MGTP"
        GTX :
          add(gtx-banks, bank)
          "MGTX"
        GTH :
          add(gth-banks, bank)
          "MGTH"
      val pin-name = to-string $ "%_[%_].C[%_].%_.%_" % [class-str, bank, index(tqt), dir-str, pol-str]
      PinProperties(pin-name, pin-refs(p), bank)
    else :
      PinProperties(name(p), pin-refs(p), maybe-default(bank(p), 0))

  val port-decls = to-tuple $ for (name in ["MGTP", "MGTX", "MGTH"], banks in [gtx-banks, gtp-banks, gth-banks]) seq? :
    if length(banks) > 0 :
      One(PortDeclaration(name, "virtex-7-serial-quad", qsort(banks)))
    else :
      None()

  [port-decls, props]

;Converts IO pins into rows for the pin properties table
defn make-io-pin-properties (pins:Vector<IOXilinxPin>) -> [Tuple<PortDeclaration>,Tuple<PinProperties>] :
  val banks = IntTable<Vector<IOXilinxPin>>()
  for p in pins do :
    val bank-vec = set?(banks, bank(p), {Vector<IOXilinxPin>()})
    add(bank-vec, p)

  val props = to-tuple $ for kv in banks seq-cat :
    val bid = key(kv)
    val bank = value(kv)
    if length(bank) != 50 :
      throw(Exception("Bank %_ does not have 50 pins: %_" % [bid, length(bank)]))
    for p in bank seq :
      if channel(p) == 0 :
        PinProperties(to-string("IO[%_].S[0]" % [bid]), [pin-ref(p)], bid)
      else if channel(p) == 25 :
        PinProperties(to-string("IO[%_].S[0]" % [bid]), [pin-ref(p)], bid)
      else :
        val cid = channel(p)
        val diff-pol = match(find({_ is DifferentialIOType}, funcs(p))) :
          (dt:DifferentialIOType) : polarity(dt)
          (_) : throw(Exception("Channel %_ of bank %_ is not a differential pair" % [cid, bid]))
        if diff-pol is Diff-P :
          val i = (2 * cid) - 1
          PinProperties(to-string("IO[%_].D[%_].P" % [bid, cid]), [pin-ref(p)], bid)
        else :
          val i = 2 * cid
          PinProperties(to-string("IO[%_].D[%_].N" % [bid, cid]), [pin-ref(p)], bid)

  val bank-ids = qsort $ to-tuple $ keys(banks)
  val bank-decl = PortDeclaration("IO", "virtex-7-io-bank", bank-ids)
  [[bank-decl], to-tuple(props)]

;============================================================
;======================== Utilities =========================
;============================================================

defn strip-bank (name:String) -> String :
  name[0 to last-index-of-char(name, '_')]

defn with-default<?T> (x:?T|False, default:?T) -> T :
  match(x) :
    (x:T) : x
    (_) : default

defn maybe-default<?T> (x:Maybe<?T>, default:?T) -> T :
  match(x) :
    (x:One<T>) : value(x)
    (_) : default

;============================================================

;Deprecated
val EXCLUDED-ROW-CHARS = ['I', 'O', 'Q', 'S', 'X', 'Z']
defn row-name-to-index (row-name:String) -> Int :
  defn row-char-to-index (c:Char) -> Int :
    if c < 'A' or c > 'Z' :
      throw(Exception("Invalid character in row index: %_" % [c]))
    val offset = with-default{_, 6} $ for e in EXCLUDED-ROW-CHARS index-when :
      if c == e :
        throw(Exception("Invalid character in row index: %_" % [c]))
      c < e
    to-int(c) - to-int('A') - offset + 1
  val base = 26 - length(EXCLUDED-ROW-CHARS)
  reduce({base * _0 + _1}, 0, seq(row-char-to-index, row-name))
