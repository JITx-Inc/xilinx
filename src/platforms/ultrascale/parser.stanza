defpackage xilinx/platforms/ultrascale/parser :
  import core
  import collections
  import maybe-utils

  import pcre

  import xilinx/pinouts
  import xilinx/pin-ir
  import xilinx/pad-ref
  import xilinx/parser-utilities
  import xilinx/platforms/ultrascale/types

;============================================================
;================ Dedicated Pin Name Parsing ================
;============================================================

defn parse-int (type:Int -> SpecialFunction) -> (Tuple<String> -> SpecialFunction) :
  fn (comps:Tuple<String>) : type(to-int!(comps[0]))

defn parse-vcco-psio (comps:Tuple<String>) -> PSIOPowerSupplyType :
  val index = to-int!(comps[0])
  val bank = to-int!(comps[1])
  PSIOPowerSupplyType(index, bank)

defn parse-ddr-dqs (comps:Tuple<String>) -> PSDDRStrobeType :
  val polarity = letter-to-polarity(comps[0])
  val index = to-int!(comps[1])
  PSDDRStrobeType(index, polarity)

defn parse-ddr-clock (comps:Tuple<String>) -> PSDDRClockType :
  val polarity = Diff-N when comps[0] == "_N" else Diff-P
  val index = to-int!(comps[1])
  PSDDRClockType(index, polarity)

defn parse-serial-quad (comps:Tuple<String>) -> TransceiverQuadType :
  val class = switch(comps[1]) :
    "R" : GTR
    "Y" : GTY
    "H" : GTH
  val dir = switch(comps[2]) :
    "TX" : GTTX
    "RX" : GTRX
  val polarity = letter-to-polarity(comps[3])
  val index = to-int!(comps[4])
  TransceiverQuadType(class, index, dir, polarity)

defn parse-serial-clock (comps:Tuple<String>) -> TransceiverClockType :
  val index = to-int!(comps[1])
  val polarity = letter-to-polarity(comps[2])
  TransceiverClockType(index, polarity)

;Dedicated pin name pattern to special function map
val dedicated-map:Tuple<KeyValue<String,SpecialFunction|Tuple<SpecialFunction>|(Tuple<String> -> SpecialFunction)>> = [
  "NC" => NoConnectType()

  ; Config
  "PUDC_B" => ConfigType()
  "POR_OVERRIDE" => ConfigType()
  "PS_DONE" => ConfigType()
  "PS_ERROR_OUT" => ConfigType()
  "PS_ERROR_STATUS" => ConfigType()
  "PS_INIT_B" => ConfigType()
  "PS_JTAG_TCK" => ConfigType()
  "PS_JTAG_TDI" => ConfigType()
  "PS_JTAG_TDO" => ConfigType()
  "PS_JTAG_TMS" => ConfigType()
  "PS_MODE([0-3])" => parse-int(PSMultiplexedIOModeType)
  "PS_PADI" => ConfigType()
  "PS_PADO" => ConfigType()
  "PS_POR_B" => ConfigType()
  "PS_PROG_B" => ConfigType()
  "PS_REF_CLK" => ConfigType()
  "PS_SRST_B" => ConfigType()

  ; Power
  "GND" => GroundType()
  "RSVDGND" => GroundType()
  "VCCINT" => PowerRailType()
  "VCCINT_IO" => PowerRailType()
  "VCCINT_VCU" => PowerRailType()
  "VCCAUX" => PowerRailType()
  "VCCAUX_IO" => PowerRailType()
  "VCCBRAM" => PowerRailType()
  "VREF_(\\d+)" => parse-int(PowerRailType)
  "VCC_PSAUX" => PowerRailType()
  "VCC_PSBATT" => PowerRailType()
  "VCC_PSDDR_PLL" => PowerRailType()
  "VCC_PSPLL" => PowerRailType()
  "VCC_PSINTFP" => PowerRailType()
  "VCC_PSINTFP_DDR" => PowerRailType()
  "VCC_PSINTLP" => PowerRailType()
  "VCCO_(\\d+)" => parse-int(PowerRailType)
  "VCCO_PSIO(\\d+)_(\\d+)" => parse-vcco-psio
  "VCCO_PSDDR_(\\d+)" => parse-int(PowerRailType)

  ; Analog
  "VCCADC" => [PowerRailType(), ADCType()]
  "GNDADC" => [PowerRailType(), ADCType()]
  "VCC_PSADC" => [PowerRailType(), ADCType()]
  "GND_PSADC" => [PowerRailType(), ADCType()]
  "VP" => [ADCType(), AnalogInputType(16, Diff-P)]
  "VN" => [ADCType(), AnalogInputType(16, Diff-N)]
  "VREFP" => [ADCType(), AnalogRefType(Diff-P)]
  "VREFN" => [ADCType(), AnalogRefType(Diff-N)]
  "DXP" => TempDiodeType(Diff-P)
  "DXN" => TempDiodeType(Diff-N)

  ; DDR
  "PS_DDR_DQ(\\d+)" => parse-int(PSDDRDataType)
  "PS_DDR_DQS_([NP])(\\d+)" => parse-ddr-dqs
  "PS_DDR_ALERT_N" => PSDDRAlertType()
  "PS_DDR_ACT_N" => PSDDRActivationType()
  "PS_DDR_A(\\d+)" => parse-int(PSDDRAddrType)
  "PS_DDR_BA(\\d+)" => parse-int(PSDDRBankAddrType)
  "PS_DDR_BG(\\d+)" => parse-int(PSDDRBankGroupType)
  "PS_DDR_CK(_N|)(\\d+)" => parse-ddr-clock
  "PS_DDR_CKE" => parse-int(PSDDRClockEnableType)
  "PS_DDR_CS_N(\\d+)" => parse-int(PSDDRChipSelectType)
  "PS_DDR_DM(\\d+)" => parse-int(PSDDRDataMaskType)
  "PS_DDR_ODT(\\d+)" => parse-int(PSDDRTerminationControlType)
  "PS_DDR_PARITY" => PSDDRParityType()
  "PS_DDR_RAM_RST_N" => PSDDRResetType()
  "PS_DDR_ZQ" => PSDDRZQType()

  ; Multiplexed I/O
  "PS_MIO(\\d+)" => parse-int(PSMultiplexedIOType)

  ; Gigabit Serial Transceiver Pins
  ; Use (PS_|) instead of (PS_)? to guarantee match group creation
  "MGT(RREF|AVTTRCAL)(_[LR][NS]?)?" => TransceiverRefType()
  "PS_MGTRREF_(\\d+)" => TransceiverRefType()
  "MGT(AVCC|AVTT|VCCAUX)_[LR][NS]?" => PowerRailType(None())
  "PS_MGT(RAVCC|RAVTT)" => PowerRailType(None())
  "(PS_|)MGTREFCLK([0-3])([NP])_(\\d+)" => parse-serial-clock
  "(PS_|)MGT([HPRY])(TX|RX)([NP])([0-3])_(\\d+)" => parse-serial-quad
]

;Check if the pin name matches a dedicated pin name pattern, return the
;corresponding special function(s) if so
defn extract-dedicated-funcs (name:String) -> Maybe<Tuple<SpecialFunction>> :
  for kv in dedicated-map first :
    val patt = key(kv)
    val func = value(kv)
    val reg-res = re-match(patt, name)
    if end(reg-res) >= 0 and (length(result(reg-res)[0]) == length(name)) :
      match(func) :
        (func:Tuple<SpecialFunction>) :
          One(func)
        (func:(Tuple<String> -> SpecialFunction)) :
          One([func(to-tuple(result(reg-res)[1 to false]))])
    else :
      ;Either no match or not fully consumed
      None()

;============================================================
;====================== IO Pin Parsing ======================
;============================================================

defn parse-io-comp-diff (comp:String) -> Maybe<[Int,Diff-Polarity]> :
  val n = length(comp)
  if prefix?(comp, "L") and (suffix?(comp, "P") or suffix?(comp, "N")) :
    match(to-int(comp[1 to (n - 1)])) :
      (i:Int) :
        val diff-pol =
          switch(comp[n - 1]) :
            'P' : Diff-P
            'N' : Diff-N
        One([i, diff-pol])
      (_) : None()
  else : None()

defn parse-io-comp-byte (comp:String) -> Maybe<[Int,NibbleLocation]> :
  val n = length(comp)
  if prefix?(comp, "T") and (suffix?(comp, "U") or suffix?(comp, "L")) :
    match(to-int(comp[1 to (n - 1)])) :
      (i:Int) :
        val nibble =
          switch(comp[n - 1]) :
            'U' : UpperNibble
            'L' : LowerNibble
        One([i, nibble])
      (_) : None()
  else : None()

defn parse-io-comp-pin-index (comp:String) -> Maybe<Int> :
  val n = length(comp)
  if prefix?(comp, "N") :
    match(to-int(comp[1 to false])) :
      (i:Int) :
        One(i)
      (_) : None()
  else : None()

val io-map = [
  "GC" => GlobalClockType(),
  "HDGC" => HighDensityGlobalClockType(),
  "VRP" => DCIRefType(DCI-P),
  "DBC" => DedicatedByteClockType(),
  "QBC" => QuadByteClockType(),
  "I2C" => false ;ignore, next component will be parsed
  "SCLK" => I2CClockType(),
  "SDA" => I2CDataType(),
  "SMBALERT" => PMBusAlertType()
  ]
defn parse-io-comp (comp:String, full-name:String) -> SpecialFunction|False :
  val n = length(comp)
  label<SpecialFunction|False> return :
    for kv in io-map do :
      if key(kv) == comp :
        return(value(kv))

    if prefix?(comp, "PERSTN") :
      match(to-int(comp[6 to false])) :
        (i:Int) :
          if i < 0 or i > 1 :
            throw(Exception("Invalid index %_ for PCI reset pin: %_" % [i, full-name]))
          return(PCIResetType(i))
        (_) : false

    if prefix?(comp, "AD") and (suffix?(comp, "P") or suffix?(comp, "N")) :
      match(to-int(comp[2 to (n - 1)])) :
        (i:Int) :
          val diff-pol =
            switch(comp[n - 1]) :
              'P' : Diff-P
              'N' : Diff-N
          return(AnalogInputType(i, diff-pol))
        (_) : false

    println("Warning: could not parse IO pin name component: %_" % [comp])
    false

doc: \<DOC>
Parses an Ultrascale IO pin

High-performance differential pin name format:
IO_L[1:24][P/N]_T[0:3][U/L]_N[0:12]_[multi-function]_[bank number]

High-performance single-ended pin name format:
IO_T[0:3][U/L]_N[0:12]_[multi-function]_[bank number]

High-density differential pin name format:
IO_L[1:24][P/N]_[multi-function]_[bank number]

where:
- L[1:24] = diff pair index
- P/N = diff polarity
- T[0:3] = memory byte group
- U/L = nibble location (upper/lower)
- N = pin number (within byte group)

Multi-function groups are additional auxiliary functions which the pin supports
<DOC>
defn extract-io-pin (pd:PinDescriptor) -> USIOPin :
  val name = /name(pd)
  val comps = to-tuple $ split(name, "_")
  val n = length(comps)

  if comps[0] != "IO" :
    throw(Exception("%_ is not an IO pin" % [name]))

  if n < 2 :
    throw(Exception("%_ is an invalid IO pin name: no bank number found % [name]"))
  val bank = match(to-int(comps[n - 1])) :
    (bank:Int) : bank
    (_) :
      throw(Exception("%_ is an invalid IO pin name: invalid bank number %_" % [name, comps[n - 1]]))

  val funcs = Vector<SpecialFunction>()
  var diff-index:Maybe<Int> = None()
  var polarity:Maybe<Diff-Polarity> = None()
  var group-index:Maybe<Int> = None()
  var nibble:Maybe<NibbleLocation> = None()
  var pin-index:Maybe<Int> = None()
  for comp in comps[1 to (n - 1)] do :
    label<False> continue :
      if diff-index is None :
        match(parse-io-comp-diff(comp)) :
          (o:One<[Int,Diff-Polarity]>) :
            val [i, p] = value(o)
            diff-index = One(i)
            polarity = One(p)
            add(funcs, DifferentialIOType(p))
            continue(false)
          (_) : false

      if group-index is None :
        match(parse-io-comp-byte(comp)) :
          (o:One<[Int,NibbleLocation]>) :
            val [i, nb] = value(o)
            group-index = One(i)
            nibble = One(nb)
            continue(false)
          (_) : false

      if pin-index is None :
        match(parse-io-comp-pin-index(comp)) :
          (o:One<Int>) :
            pin-index = o
            continue(false)
          (_) : false

      match(parse-io-comp(comp, name)) :
        (func:SpecialFunction) : add(funcs, func)
        (_) : false

  match(diff-index, group-index) :
    (di:One<Int>, gi:One<Int>) :
      USHPDiffIOPin(name, PadRef(pin-ref(pd)), bank,
        value(di), value(polarity as One<Diff-Polarity>),
        value(gi), value(nibble as One<NibbleLocation>),
        to-tuple(funcs))
    (di:One<Int>, gi:None) :
      USHDIOPin(name, PadRef(pin-ref(pd)), bank,
        value(di), value(polarity as One<Diff-Polarity>),
        to-tuple(funcs))
    (di:None, gi:One<Int>) :
      USHPSingleIOPin(name, PadRef(pin-ref(pd)), bank,
        value(gi), value(nibble as One<NibbleLocation>),
        to-tuple(funcs))
    (di:One<Int>, gi:One<Int>) :
      throw(Exception("IO pin %_ has no diff index or byte group" % [name]))

;============================================================
;======================= Pin Parsing ========================
;============================================================

doc: \<DOC>
Parse a pin descriptor into an Ultrascale pin
<DOC>
public defn parse (pd:PinDescriptor) -> UltrascalePin :
  val n = name(pd)
  val [m-name, bank?] = split-on-bank(n)
  ;Sanity check to ensure the name suffix number (if it exists) matches the CSV
  ;bank column bank number
  match(bank?, bank(pd)):
    (x:One<Int>, y:One<Int>):
      val name-bank = value(x)
      val parent-bank = value(y)
      if name-bank != parent-bank:
        throw(Exception("CSV bank %_ does not match name bank %_ for pin '%_'" % [parent-bank, name-bank, n]))
    (x:One<Int>, y:None):
      throw(Exception("Pin '%_' has name bank %_ but no bank in the CSV" % [n, value(x)]))
    (x, y): false

  defn parse-dedicated () -> Maybe<USDedicatedPin> :
    match(extract-dedicated-funcs(n)) :
      (funcs:One<Tuple<SpecialFunction>>) :
        One(USDedicatedPin(n, PadRef(pin-ref(pd)), bank?, value(funcs)))
      (_) :
        None()

  defn parse-io () -> Maybe<USIOPin> :
    if prefix?(m-name, "IO_") :
      One(extract-io-pin(pd))
    else :
      None()

  ;Try each parse strategy, return first successful result
  match(first({_()}, [parse-dedicated, parse-io])) :
    (p:One<UltrascalePin>) : value(p)
    (_) : throw(Exception("Could not parse pin descriptor %_" % [pd]))
