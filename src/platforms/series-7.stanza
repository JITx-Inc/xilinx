defpackage xilinx/platforms/series-7:
  import core
  import maybe-utils

  import xilinx/pinouts
  import xilinx/pin-ir

doc: \<DOC>
Clock Input Function Type

The 7-series FPGA's support two different clock
input special functions:

1. Multi-Region Clocks
2. Single-Region Clocks
<DOC>
public deftype ClockInputType <: SpecialFunction
public defstruct MultiRegionClockType <: ClockInputType
public defstruct SingleRegionClockType <: ClockInputType


doc: \<DOC>
Memory Group Type

This type is used to outline which byte lane for the memory
interface that this pin supports.
<DOC>
public defstruct MemoryGroupType <: SpecialFunction & IndexableType :
  index:Int with: (as-method => true)


doc: \<DOC>
Memory Strobe (DQS) Function Type
<DOC>
public defstruct MemoryStrobeType <: SpecialFunction


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; High Performance Transceivers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

public defstruct SerialTransceiverType <: SpecialFunction

public defenum GigabitClass:
  GTP
  GTX
  GTH

public defstruct TransceiverQuadType <: SerialTransceiverType & PolarizedType & IndexableType :
  class:GigabitClass
  index:Int with: (as-method => true)
  polarity:Diff-Polarity with: (as-method => true)

public defstruct TransceiverClockType <: SerialTransceiverType & PolarizedType & IndexableType :
  index:Int with: (as-method => true)
  polarity:Diff-Polarity with: (as-method => true)

public defstruct TransceiverRefType <: SerialTransceiverType


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pin Name Parsing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

defn parse-mode-pin (name:String) -> SpecialFunction|Tuple<SpecialFunction> :
  ; @TODO parse the name string to extract the index.
  val index = 0
  ConfigModeType(index)

defn parse-bank-rail (name:String) -> SpecialFunction|Tuple<SpecialFunction> :
  val bank = 0
  PowerRailType(bank)

defn parse-serial-transceiver (name:String) -> SpecialFunction|Tuple<SpecialFunction> :
  ; TODO - Parse one of:
  ; TransceiverQuadType
  ; TransceiverClockType
  ; TransceiverRefType
  ; PowerRailType
  TransceiverRefType()

; Map of String : Function
;  The string is the pin name that we will match against
;   with the bank ID (`_0` for bank 0) removed.
;   The string can include the `*` glob pattern string for
;   matching against a set of options.
;  The function is called with the pin name as the
;  argument.
;  The function returns either a `SpecialFunction` or
;  a `Tuple<SpecialFunction>`
val dedicated-map = [
  ; Config
  ["CCLK", {ConfigType()}],
  ["DONE", {ConfigType()}],
  ["INIT_B", {ConfigType()}],
  ["PROGRAM_B", {ConfigType()}],
  ["M.", parse-mode-pin]
  ["TCK", {JTAGType(TCK)}]
  ["TDI", {JTAGType(TDI)}]
  ["TDO", {JTAGType(TDO)}]
  ["TMS", {JTAGType(TMS)}]
  ["CFGBVS", {ConfigType()}]
  ; Power
  ["GND", {GroundType()}]
  ["RSVDGND", {GroundType()}]
  ["VCCAUX", {PowerRailType()}]
  ["VCCAUX_IO_G.", {PowerRailType()}]
  ["VCCINT", {PowerRailType()}]
  ["VCCO_*", parse-bank-rail]
  ["VCCBRAM", {PowerRailType()}]
  ["VCCBATT", {PowerRailType()}]
  ; Analog
  ["VCCADC", {[PowerRailType(), ADCType()]}]
  ["GNDADC", {[PowerRailType(), ADCType()]}]
  ["VP", {[ADCType(), AnalogInputType(16, Diff-P)]}]
  ["VN", {[ADCType(), AnalogInputType(16, Diff-N)]}]
  ["VREFP", {[ADCType(), AnalogRefType(Diff-P)]}]
  ["VREFN", {[ADCType(), AnalogRefType(Diff-N)]}]
  ["DXP", {TempDiodeType(Diff-P)}]
  ["DXN", {TempDiodeType(Diff-N)}]

  ; Gigabit Serial Transceiver Pins
  ["MGT*", parse-serial-transceiver]
]

defenum MATCH-TYPE :
  MATCH_STRICT
  MATCH+1
  MATCH+N

defn find-prefix (pattern:String) -> [String, MATCH-TYPE] :
  label<[String, MATCH-TYPE]> return:
    val single? = index-of-char(pattern, '.')
    match(single?):
      (_:False): false
      (x:Int):
        return([pattern[0 to x], MATCH+1])

    val multi? = index-of-char(pattern, '*')
    match(multi?):
      (_:False):
        return([pattern, MATCH_STRICT])
      (x:Int):
        return([pattern[0 to x], MATCH+N])

defn glob (v:String, pattern:String) -> True|False :
  val [pat-prefix, pat-type] = find-prefix(pattern)

  val index? = index-of-chars(v, pat-prefix)
  match(index?):
    (_:False): false
    (x:Int):
      switch(pat-type):
        MATCH_STRICT:
          length(v) == length(pat-prefix)
        MATCH+1:
          length(v) == (length(pat-prefix) + 1)
        MATCH+N:
          length(v) > length(pat-prefix)

defn find-dedicated-transform (v:String) -> Maybe<[String, (String -> SpecialFunction|Tuple<SpecialFunction>)]> :
  for pair in dedicated-map first:
    val [pattern, func] = pair
    if glob(v, pattern):
      One $ pair
    else:
      None()

doc: \<DOC>
Split the IO pin name on the bank identifier

Each IO pin has a `_NNN` suffix, for which `NNN` is
the integer number denoting the bank of this pin.

High Speed IO hav a `_G0` or `_G1` suffix.

Power pins may not have any suffix, like `GND` or `VCCINT`
<DOC>
defn split-on-bank (name:String) -> Maybe<[String, String]>:
  val index = last-index-of-char(name, '_')
  match(index):
    (_:False): None()
    (v:Int):
      One $ [name[0 to v], name[ (v + 1) to length(name)]]

defn extract-diff-pair (v:String) -> [Int, Maybe<Diff-Polarity>]:
  if length(v) == 0:
    throw $ Exception("Empty String Encountered in Pin ID Extraction")

  if v[0] == 'L':
    val num-str = v[1 to (length(v) - 1)]
    val num? = to-int(num-str)
    val dp = v[length(v) - 1]

    val pol = switch(dp):
      'P': Diff-P
      'N': Diff-N
      else:
        throw $ Exception("Invalid Diff Pair Polarity: '%_'" % [dp])

    match(num?):
      (_:False): throw $ Exception("Failed to Extract Pin Id: '%_'" % [v])
      (num:Int):
        [num, One(pol)]
  else:
    match(to-int(v)):
      (_:False):
        throw $ Exception("Failed to Extract Pin Id: '%_'" % [v])
      (num:Int):
        [num, None()]


defn extract-io-pin (name:String, bank:Maybe<Int>) -> XilinxPinType :
  ; Pin names look like this:
  ; IO_L(\d+)(P|N)_T(\d+)_(([^_]+)_?)*
  ;
  ;  Where L = Diff Pair index and P/N spec
  ;        T = Memory Group (for bytelanes in DDR)
  ;        Final Groups are multi-function features of pins which may be things
  ;        like:
  ;           EMCCLK
  ;           PUDC_B
  ;           etc
  ; The Bank has already been stripped at this point.

  if not prefix?(name, "IO_"):
    throw $ Exception("Unexpected Pin Name '%_' - Expected 'IO_' prefix" % [name])

  val spec-funcs = Vector<SpecialFunction>()

  val comps = to-tuple $ split(name, "_", 3)
  val Ld = comps[1]
  val [io-id, diff?] = extract-diff-pair(Ld)
  match(diff?):
    (x:One<Diff-Polarity>):
      add(spec-funcs, DifferentialIOType(value(x)))
    (_): false


  IOPinType(
    value!(bank),
    io-id,
    to-tuple(spec-funcs)
  )



doc: \<DOC>
Parse a Pin Descriptor into a XilinxPinType

This Constructs the PinIR for a Pin Descriptor object.
<DOC>
public defn parse (pd:PinDescriptor) -> XilinxPinType :

  val n = name(pd)

  val bank-suffix? = split-on-bank(n)
  val [m-name, bank?] = match(bank-suffix?):
    (_:None): [n, None()]
    (o:One<[String, String]>):
      val comps = value(o)
      [comps[0], to-maybe $ to-int(comps[1])]

  ; Do some sanity checking and logs
  ;  some strange conditions.
  match(bank?, bank(pd)):
    (x:One<Int>, y:One<Int>):
      val name-bank = value(x)
      val parent-bank = value(y)
      if name-bank != parent-bank:
        println("Pin '%_' - Bank in CSV '%_' does not match Bank in Name '%_'!" % [n, parent-bank, name-bank])
    (x:One<Int>, y:None):
      println("Pin '%_' - Bank in CSV Absent - but Name has a Bank '%_'" % [n, value(x)])
    (x,y): false

  val transform? = find-dedicated-transform(m-name)
  match(transform?):
    (x:One<[String, (String -> SpecialFunction|Tuple<SpecialFunction>)]>):
      val [pattern, func] = value(x)
      val spec-funcs = func(m-name)
      DedicatedPinType(spec-funcs)
    (_:None):
      extract-io-pin(m-name, bank?)



  ; If that fails - then we try parsing the IO pins style.
